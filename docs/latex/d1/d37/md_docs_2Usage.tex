\chapter{Usage}
\hypertarget{md_docs_2Usage}{}\label{md_docs_2Usage}\index{Usage@{Usage}}
\label{md_docs_2Usage_autotoc_md74}%
\Hypertarget{md_docs_2Usage_autotoc_md74}%
 To use Tannic, simply include it in your project and interact with it similarly to a Python framework\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <tannic.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using\ namespace\ }\mbox{\hyperlink{namespacetannic}{tannic}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()\ \{\ }
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtannic_1_1Tensor}{Tensor}}\ X(float32,\ \{2,2\});\ \textcolor{comment}{//\ and\ X.initialize(Device())\ for\ CUDA\ support}}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ X[0,\ \mbox{\hyperlink{structtannic_1_1indexing_1_1Range}{range}}\{0,-\/1\}]\ =\ 1;\ \ }
\DoxyCodeLine{\ \ \ \ X[1,0]\ =\ 3;\ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ X[1,1]\ =\ 4;\ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtannic_1_1Tensor}{Tensor}}\ Y(float64,\ \{1,2\});\ }
\DoxyCodeLine{\ \ \ \ Y[0,0]\ =\ 4;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ Y[0,1]\ =\ 6;\ \ \ \ }
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ Y\ =\ \mbox{\hyperlink{namespacetannic_1_1function_a9ec44a47e78a5e28b75b76573d98e06b}{log}}(X)\ +\ Y\ *\ Y\ -\/\ \mbox{\hyperlink{namespacetannic_1_1function_a1a8e818c37a5236e4481677e70ce6209}{exp}}(X)\ +\ \mbox{\hyperlink{namespacetannic_a3681656aa208b88dfc79a1806cf669b6}{matmul}}(X,\ Y.transpose());\ \textcolor{comment}{//\ assign\ expressions\ dynamically\ like\ in\ python}}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ Y;}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtannic_1_1Tensor}{Tensor}}\ Z\ =\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{1,2,3,4\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{2,3,4,5\}}
\DoxyCodeLine{\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ int\ tensor}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtannic_1_1Tensor}{Tensor}}\ W\ =\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{1.0f,\ 2.0f,\ 3.0f\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{1.0f,\ 2.0f,\ 3.0f\}}
\DoxyCodeLine{\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ float\ tensor}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \mbox{\hyperlink{namespacetannic_1_1expression_a83caa2ee55fd9f434b633d9eba583b61}{argmax}}(Z)\ <<\ std::endl>>}
\DoxyCodeLine{\}}

\end{DoxyCode}


Functions in Tannic do not immediately compute results. Instead, they build Expression objects, described in detail in the \href{https://entropy-flux.github.io/Tannic/concepts.html}{\texttt{ concepts}} documentation. Basically an {\ttfamily Expression} is any class that follows the pattern\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }Expression\ =\ \textcolor{keyword}{requires}(\textcolor{keyword}{const}\ T\ expression)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ expression.dtype()\ \ \ \}\ -\/>\ std::same\_as<type>;}
\DoxyCodeLine{\ \ \ \ \{\ expression.shape()\ \ \ \}\ -\/>\ std::same\_as<Shape\ const\&>;}
\DoxyCodeLine{\ \ \ \ \{\ expression.strides()\ \}\ -\/>\ std::same\_as<Strides\ const\&>;}
\DoxyCodeLine{\ \ \ \ \ \ expression.offset();\ \ \textcolor{comment}{//\ convertible\ to\ ptrdifft\_t}}
\DoxyCodeLine{\ \ \ \ \ \ expression.forward();\ \textcolor{comment}{//\ same\ as\ Tensor\ or\ Tensor\ const\&}}
\DoxyCodeLine{\};\ }

\end{DoxyCode}


Any class that follows that pattern is a valid Tannic expression and can interact with other components of the library. All available expressions are detailed under the \href{https://entropy-flux.github.io/Tannic/annotated.html}{\texttt{ class list}} section. You can scroll to the members of each expression and find information about how dtypes are promoted, or how shapes are calculated.

The library is built around the Host-\/\+Device computational model, so in order to use CUDA you just have to initialize kernels tensors on the Device you want to use, for example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()\ \{\ }
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtannic_1_1Tensor}{Tensor}}\ X(float32,\ \{2,2\});\ X.\mbox{\hyperlink{classtannic_1_1Tensor_a4ee063da4965ea868081841b3d967882}{initialize}}(\mbox{\hyperlink{classtannic_1_1Device}{Device}}());}
\DoxyCodeLine{\ \ \ \ X[0,\ \mbox{\hyperlink{structtannic_1_1indexing_1_1Range}{range}}\{0,-\/1\}]\ =\ 1;\ \ \ \textcolor{comment}{//\ assignment\ just\ works\ the\ same\ on\ device}}
\DoxyCodeLine{\ \ \ \ X[1,0]\ =\ 3;\ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ X[1,1]\ =\ 4;\ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtannic_1_1Tensor}{Tensor}}\ Y(float32,\ \{1,2\});\ Y.\mbox{\hyperlink{classtannic_1_1Tensor_a4ee063da4965ea868081841b3d967882}{initialize}}(\mbox{\hyperlink{classtannic_1_1Device}{Device}}());}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ Y\ =\ \mbox{\hyperlink{namespacetannic_1_1function_a9ec44a47e78a5e28b75b76573d98e06b}{log}}(X)\ +\ Y\ *\ Y\ -\/\ \mbox{\hyperlink{namespacetannic_1_1function_a1a8e818c37a5236e4481677e70ce6209}{exp}}(X)\ +\ \mbox{\hyperlink{namespacetannic_a3681656aa208b88dfc79a1806cf669b6}{matmul}}(X,\ Y.transpose());\ \textcolor{comment}{//\ assign\ expressions\ dynamically\ like\ in\ python}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Y\ is\ now\ calculated\ using\ CUDA.}}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\}}

\end{DoxyCode}


The library currently lacks of some easily implementable CUDA features like copying a tensor from Host to Device and viceversa or printing CUDA tensors, I will add them soon. ~\newline


Data types are dynamic to make it easier to serialize and deserialize tensors at runtime, and deliver machine learning models that can work with arbitrary data types. They are represented using a C enum to be compatible with the C api runtime on wich the library relies on.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum}\ type\ \{\ }
\DoxyCodeLine{\ \ \ \ none,}
\DoxyCodeLine{\ \ \ \ int8,}
\DoxyCodeLine{\ \ \ \ int16,}
\DoxyCodeLine{\ \ \ \ int32,}
\DoxyCodeLine{\ \ \ \ int64,}
\DoxyCodeLine{\ \ \ \ float32,}
\DoxyCodeLine{\ \ \ \ float64,}
\DoxyCodeLine{\ \ \ \ complex64,\ \ \ }
\DoxyCodeLine{\ \ \ \ complex128,\ \ }
\DoxyCodeLine{\ \ \ \ TYPES}
\DoxyCodeLine{\};}

\end{DoxyCode}


This design also paves the way for future features such as tensor quantization. 